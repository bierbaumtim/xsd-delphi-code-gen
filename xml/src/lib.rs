#![allow(clippy::too_many_lines)]

use std::{fs::File, io::BufWriter, path::PathBuf, time::Instant};

pub mod generator;
pub mod parser;

use generator::{
    code_generator_trait::{CodeGenOptions, CodeGenerator},
    delphi::code_generator::DelphiCodeGenerator,
    internal_representation::InternalRepresentation,
};
use genphi_core::type_registry::TypeRegistry;
use parser::{types::ParsedData, xml::XmlParser};

use crate::parser::types::CustomTypeDefinition;

pub fn generate_xml(source: &[PathBuf], output_path: &PathBuf, options: CodeGenOptions) {
    let overall_instant = Instant::now();

    let output_file = match File::create(output_path) {
        Ok(f) => f,
        Err(e) => {
            eprintln!("Could not create output file due to following error: \"{e:?}\"");
            return;
        }
    };

    let mut parser = XmlParser::default();
    let mut type_registry = TypeRegistry::<CustomTypeDefinition>::new();

    let data: ParsedData = if source.len() == 1 {
        match parser.parse_file(source.first().unwrap(), &mut type_registry) {
            Ok(n) => n,
            Err(error) => {
                eprintln!("An error occured: {error}");
                return;
            }
        }
    } else {
        match parser.parse_files(source, &mut type_registry) {
            Ok(n) => n,
            Err(error) => {
                eprintln!("An error occured: {error}");
                return;
            }
        }
    };

    let internal_representation = InternalRepresentation::build(&data, &type_registry);

    let buffer = BufWriter::new(Box::new(output_file));
    let mut generator = DelphiCodeGenerator::new(
        buffer,
        options.clone(),
        internal_representation,
        data.documentations,
    );

    match generator.generate() {
        Ok(()) => {
            println!(
                "Completed successfully within {}ms",
                overall_instant.elapsed().as_millis(),
            );
        }
        Err(e) => {
            eprintln!("Failed to write output to file due to following error: \"{e:?}\"");
            return;
        }
    }

    // Generate validation schemes unit if validation is enabled
    if options.enable_validation {
        if let Err(e) = generate_validation_schemes_unit(&options.xsd_file_paths, output_path) {
            eprintln!("Failed to generate validation schemes unit: {e:?}");
        }
    }
}

fn generate_validation_schemes_unit(
    xsd_paths: &[PathBuf],
    output_path: &PathBuf,
) -> Result<(), std::io::Error> {
    use std::fs;

    // Determine the output path for the validation schemes unit
    let validation_unit_path = output_path
        .parent()
        .unwrap_or_else(|| std::path::Path::new("."))
        .join("uValidationSchemes.pas");

    let mut unit_content = String::from(
        r#"// ========================================================================== //
// Generated by Delphi Code Gen - Validation Schemes Unit                     //
// ========================================================================== //

unit uValidationSchemes;

interface

uses msxml;

procedure LoadSchemas(pSchemaCache: IXMLDOMSchemaCollection2);

implementation

procedure LoadSchemas(pSchemaCache: IXMLDOMSchemaCollection2);
begin
"#,
    );

    // Read each XSD file and convert to Delphi string constant
    for (idx, xsd_path) in xsd_paths.iter().enumerate() {
        let xsd_content = match fs::read_to_string(xsd_path) {
            Ok(content) => content,
            Err(e) => {
                eprintln!(
                    "Warning: Could not read XSD file '{}': {e:?}",
                    xsd_path.display()
                );
                continue;
            }
        };

        // Escape single quotes for Delphi string
        let escaped_content = xsd_content.replace('\'', "''");

        // Split into lines for better readability
        let lines: Vec<&str> = escaped_content.lines().collect();

        unit_content.push_str(&format!("  // Schema from: {}\n", xsd_path.display()));
        unit_content.push_str(&format!("  pSchemaCache.add('', \n"));

        for (line_idx, line) in lines.iter().enumerate() {
            if line_idx == lines.len() - 1 {
                unit_content.push_str(&format!("    '{}');\n", line));
            } else {
                unit_content.push_str(&format!("    '{}' + sLineBreak +\n", line));
            }
        }

        if idx < xsd_paths.len() - 1 {
            unit_content.push('\n');
        }
    }

    unit_content.push_str(
        r#"end;

end.
"#,
    );

    fs::write(validation_unit_path, unit_content)?;

    Ok(())
}
