{% macro fixed_size_line(content, size) %}
  {%- set content_length = content | length -%}
  {%- set space_count = size - content_length -%}
  {{ content }}
  {%- for v in range(end=space_count) -%}
  {{" "}}
  {%- endfor -%}
{% endmacro fixed_size_line %}



{%- set timestamp = now() | date(format="%d.%m.%Y %H:%m:%S") -%}
// ========================================================================== //
// Generated by Delphi Code Gen - Mode OpenAPI                                //
// {{ self::fixed_size_line(content="Version: " ~ crate_version, size=74) }} //
// {{ self::fixed_size_line(content="Timestamp: " ~ timestamp, size=74) }} //
// ========================================================================== //

unit u{{unitPrefix}}ApiModels;

interface

uses System.Generics.Collections System.JSON;

type
  {$REGION 'Forward Declerations'}
  {% for classType in classTypes -%}
  T{{prefix}}{{classType.name}} = class;
  {%- endfor %}
  {$ENDREGION}

  {$REGION 'Enums and Helper'}
  {% for enumType in enumTypes -%}
  T{{prefix}}{{enumType.name}} = ({{enumType.variants | map(attribute="name") | join(sep=", ")}});
  {%- endfor %}

  {% for enumType in enumTypes -%}
  T{{prefix}}{{enumType.name}}Helper = record helper for T{{prefix}}{{enumType.name}}
    class function FromString(const pValue: String): T{{prefix}}{{enumType.name}}; static;
  end;
  {%- endfor %}
  {$ENDREGION}

  {$REGION 'Models'}
  {% for classType in classTypes -%}
  T{{prefix}}{{classType.name}} = class
  strict private
    {%- for property in classType.properties %}
    {% if property.is_list_type and property.is_reference_type -%}
    F{{property.name}}: TObjectList<{{property.type_name}}>;
    {% elif property.is_list_type -%}
    F{{property.name}}: TList<{{property.type_name}}>;
    {% else -%}
    F{{property.name}}: {{property.type_name}};
    {%- endif -%}
    {%- endfor -%}{{" "}}
  public
    constructor FromJson(const pJson: String);
    constructor FromJsonRaw(pJson: TJSONValue);
    {% if classType.needs_destructor -%}
    destructor Destroy; override;
    {%- endif -%}
    {{""}}
    {% for property in classType.properties %}
    {% if property.is_list_type and property.is_reference_type -%}
    property {{property.name}}: TObjectList<{{property.type_name}}> read F{{property.name}};
    {% elif property.is_list_type -%}
    property {{property.name}}: TList<{{property.type_name}}> read F{{property.name}};
    {% else -%}
    property {{property.name}}: {{property.type_name}} read F{{property.name}};
    {%- endif -%}
    {%- endfor %}
  end;
  {%- endfor %}
  {$ENDREGION}

implementation

uses uJsonHelper,
     System.DateUtils,
     System.SysUtils;

{$REGION 'Enumhelper'}
{% for enumType in enumTypes -%}
class function T{{prefix}}{{enumType.name}}Helper.FromString(const pValue: String): T{{prefix}}{{enumType.name}};
  {% for variant in enumType.variants -%}
  {% if loop.first -%}
  if pValue = '{{variant.key}}' then begin 
    Result := {{variant.name}}
  end
  {%- else -%}
  {{" "}}else if pValue = '{{variant.key}}' then begin 
    Result := {{variant.name}}
  end
  {%- endif -%}
  {%- endfor -%}
  {{" "}}else begin 
    raise Exception.Create('\"' + pValue + '\" is a unknown value for T{{prefix}}{{enumType.name}}');
  end;
end;
{%- endfor %}
{$ENDREGION}

{$REGION 'Models'}
{% for classType in classTypes -%}
constructor T{{prefix}}{{classType.name}}.FromJson(const pJson: String);
begin
  var vRoot := TJSONObject.ParseJSONValue(pJson);

  try
    FromJsonRaw(vRoot);
  finally
    FreeAndNil(vRoot);
  end;
end;

constructor T{{prefix}}{{classType.name}}.FromJsonRaw(pJson: TJSONValue);
begin
  {%- for property in classType.properties %}
  F{{property.name}} := '';
  {%- endfor%}
end;

{% if classType.needs_destructor -%}
destructor T{{prefix}}{{classType.name}}.Destroy;
begin
  {% for property in classType.properties -%}
  {% if property.is_reference_type or property.is_list_type -%}
  FreeAndNil(F{{property.name}});
  {% endif -%}
  {%- endfor %}
  inherited;
end;
{% endif %}
{%- endfor -%}
{$ENDREGION}

end.